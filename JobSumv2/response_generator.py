import json
import streamlit as st
import google.generativeai as genai
#from config import API_KEY
import re
import json

genai.configure(api_key = st.secrets['API_KEY'])

model = genai.GenerativeModel('gemini-1.0-pro')
chat = model.start_chat(history = [])

def chat_with_gemini(prompt):
    try:
        response = chat.send_message(prompt, stream = True)
        for chunk in response:
            yield chunk.text
    except:
        return st.error("An Error Occured! Please Try Again.")


def generate_description_string(df, slice_number, full = False):
    if not full:
        return '\n'.join(f'{i + 1}. {desc}' for i, desc in enumerate(df['description'][:slice_number], start=0))
    else:
        return '\n'.join(f'{i + 1}. {desc}' for i, desc in enumerate(df['description'], start = 0))

def set_initial_message():
    # Clearning the chat history when user creates new dataset
    chat.history.clear()
    try:
        chat.send_message(st.session_state.desc_string)
    except:
        pass

def get_json():

    """Returns: JSON generated by model"""

    prompt = """
        Extract a bunch of relevant keywords related to this job role. Here is how the format needed:

            General Kewords (List[words]):
            Skills (List[words]):
            Qualification (List[words]):
            Soft Skills (List[words]):
            Additional (List[words]):
            Other (List[words]):

            Instructions while filling:

            1. Fill those and give it as a JSON file, values must be a list.
            2. Don't Give any other suggestion or comments.
            3. Each Items inside the list must be a one word string or number (as required).
            4. Fill all the fields, its mandatory.

        """
    try:
        response = chat.send_message(prompt)
        return response.text
    except:
        st.error("An Error Occured! Please Try Again.")
    
def preprocess_json_string(json_string):
    """Returns: Cleaned Python Dictionary"""
    inner_json_match = re.search(r'{(.+)}', json_string, re.DOTALL)
    if inner_json_match:
        inner_json = '{' + inner_json_match.group(1) + '}'
        json_to_dict = json.loads(inner_json)
        return json_to_dict
    else:
        st.error("Parse Error! Try Again!")

def get_title_counts(df):
    job_counts = df['title'].value_counts()
    labels = job_counts.index
    sorted_pairs = sorted(zip(job_counts, labels), reverse = True)
    sorted_counts, sorted_labels = zip(*sorted_pairs)
    return list(sorted_counts), list(sorted_labels)

